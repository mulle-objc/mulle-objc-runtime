# Testing
<!-- Keywords: test, workflow, valgrind, coverage -->

Tests are self contained mulle-sde projects. Commands run outside of the
test folder like `mulle-sde craft` do not affect the test project.

Therefore use `mulle-sde test` commands like `mulle-sde test craft` instead.

## Testing Philosophy & Guidelines


This document outlines the testing philosophy and test procedures.

## 1. Test Workflow

To run a specific test case:

```bash
mulle-sde test [sanitizers] run <path_to_test_file>
```
*Example: `mulle-sde test --valgrind run test/NSTableView/01_initialization.m`*

Sanitizers are platform dependent. Check `mulle-test sanitizers` for a list
of supported sanitizers.

## Testing Guidelines

### Test Organization

-   Each feature or major function should have its own test file.
-   Test files should be organized in the `test/` directory, with subdirectories reflecting the component under test.
-   Test files must be accompanied by a `.stdout` file containing the exact expected output.
-   Run the tests from the project directory. Do not `cd` to any test directory.
-   After a failed test, there will be an executable with a '.exe' extension besides the test source. You can run this to observe stdout and stderr better or to run the executable in a debugger

### Test Style & Philosophy

-   **Output-Based Verification:** Tests verify correctness by comparing `mulle_printf` output to the corresponding `.stdout` file. Avoid using traditional assertion libraries.
-   **Focus and Minimalism:** Each test should be small, focused, and test one specific piece of functionality.
-   **Edge Cases:** Rigorously test edge cases, especially `nil` handling for all relevant parameters.
-   **Memory Management:** Ensure all allocated objects are properly deallocated within the test to prevent leaks.
-   **Descriptive Output:** The `mulle_printf` output should be clear and descriptive, making it easy to understand what is being tested.
-   **Mutation Safety:** For any tests involving collection enumeration, include scenarios where the collection is modified during enumeration to ensure robustness.
-   **NO Pointer or Date output**: The mulle_printf output must be deterministic, therefore should not contain memory addresses, dates, random values, pids etc. that are different on each run or for other users.

### Test Structure Example

```objective-c
#include "include.h"  // use provided header for all dependency includes

int   main( void)
{
   // 1. Setup objects and environment
   // 2. Print descriptive output of the test steps and results
   mulle_printf( "Test description: ...\n");
   // 3. Clean up and deallocate all objects
   return( 0);
}
```

### Testing Tips and Common Pitfalls

A NULL struct mulle_allocator * is almost always fine

Once you are really sure that the test output is correct, you can conveniently
create the .stdout file with

``` bash
mulle-sde test run --golden-stdout <testname>
```

### Test with Vibecode enabled

With vibecoding enabled, the files generated by the test will be besides
the testfile. Also the generated test excecutable with the suffix `.exe` will
not be removed.  Look for `<testname>.test.stderr` and `<testname>.test.stdout`
for executable output and `<testname>.test.ccdiag` for compiler errors

### Test with coverage

If asked to create tests to improve coverage see:

``` bash
mulle-sde test coverage help
```
